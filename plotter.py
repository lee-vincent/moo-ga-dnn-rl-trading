import matplotlib.pyplot as plt
import matplotlib
import datetime as dt
import time
from mpl_toolkits.mplot3d import Axes3D

# TO-DO: Implement function for calculating pareto set, and use pareto set of each gen for some plots.


class Plotter():

    def __init__(self, queue, n_gen):
        matplotlib.use('TkAgg')
        plt.ion()
        self.queue = queue
        self.max_gen = n_gen
        self.cmap = matplotlib.cm.viridis_r
        self.comp_pop_obj_data = []
        self.convergence_figure_3d = self._create_fig_ax(title="Profit vs. Drawdown vs. Trade Count", dimensions=3)
        self.convergence_figure_2d = self._create_fig_ax(title="Profit vs. Drawdown", dimensions=2)

    def update_while_training(self):
        """
        Plots objective data generated by training process on convergence scatters.
        """
        current_generation = 0
        while current_generation < self.max_gen:
            if not self.queue.empty():
                current_generation += 1
                self.comp_pop_obj_data.append(self.queue.get())
                x_data, y_data, z_data = self.comp_pop_obj_data[-1]
                self.update_interactive_convergence_scatter(
                    x_data, y_data, z_data, current_generation)
            self.convergence_figure_3d[0].canvas.flush_events()
            self.convergence_figure_2d[0].canvas.flush_events()
            time.sleep(0.1)
        plt.show(block=True)
        plt.ioff()

    def _create_fig_ax(self, title: str, dimensions: int = 2, xlabel: str = "Profit", ylabel: str = "Drawdown", zlabel: str = "Trade Count", x_percentage: bool = True, y_percentage: bool = True, z_percentage: bool = False) -> tuple:
        """
        Configures and returns base fig/ax for plots.
        """
        fig = plt.figure(f"{dimensions}D Convergence Scatter", figsize=(8, 6))
        if dimensions == 2:
            with plt.style.context('ggplot'):
                ax = fig.add_subplot()
                fig.subplots_adjust(left=0.15, right=0.95, top=0.9, bottom=0.1)
        else:
            ax = fig.add_subplot(projection='3d')
            fig.subplots_adjust(left=0, right=0.9, top=0.9, bottom=0.1)

        ax.spines['left'].set_linewidth(1)
        ax.spines['bottom'].set_linewidth(1)
        ax.spines['right'].set_color((.8, .8, .8))
        ax.spines['top'].set_color((.8, .8, .8))
        ax.set_title(title, fontsize='x-large', weight='bold')
        ax.set_xlabel(xlabel, fontsize='large',
                      fontstyle='italic', labelpad=10)
        ax.set_ylabel(ylabel, fontsize='large', fontstyle='italic', labelpad=5)

        if x_percentage:
            ax.xaxis.set_major_formatter(matplotlib.ticker.PercentFormatter())
        if y_percentage:
            ax.yaxis.set_major_formatter(matplotlib.ticker.PercentFormatter())

        sm = matplotlib.cm.ScalarMappable(
            cmap=self.cmap, norm=matplotlib.colors.Normalize(vmin=1, vmax=self.max_gen))
        sm.set_array([])
        fig.colorbar(sm, ticks=[1, self.max_gen], aspect=12, pad=0.1, fraction=0.1, shrink=0.6,
                     orientation='vertical', ax=ax, label='Generation')

        if dimensions == 3:
            ax.set_zlabel(zlabel, fontsize='large', fontstyle='italic')
            if z_percentage:
                ax.zaxis.set_major_formatter(
                    matplotlib.ticker.PercentFormatter())

        return (fig, ax)

    def update_interactive_convergence_scatter(self, x_data: list, y_data: list, z_data: list, current_gen: int) -> None:
        """
        Updates convergence scatters with objective performance data for generation.
        """
        normalized_gen = (current_gen-1) / self.max_gen
        fig_3d, ax_3d = self.convergence_figure_3d
        fig_2d, ax_2d = self.convergence_figure_2d
        ax_3d.scatter(x_data, y_data, z_data, color=self.cmap(normalized_gen))
        ax_2d.scatter(x_data, y_data, color=self.cmap(normalized_gen), alpha=0.6)

    def create_gen_scatter(self, title: str, dimensions: int, gen: int) -> None:
        """
        Generates scatter of performance data on objectives for passed generation. 
        """
        fig, ax = self._create_fig_ax(title, dimensions)
        x_data, y_data, z_data = self.comp_pop_obj_data[gen-1]
        normalized_gen = gen / self.max_gen
        if dimensions == 2:
            ax.scatter(x_data, y_data, color=self.cmap(normalized_gen))
        else:
            ax.scatter(x_data, y_data, z_data, color=self.cmap(normalized_gen))
        fig.canvas.draw()
        timestamp = dt.datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
        fig.savefig(f"Figures/{timestamp}_{title}_scatter.png")

    # def stop_losses_triggered(stop_loss_data: list, network_decision_data: list, gen_id: int, pop_id: int) -> None:
    #     """
    #     Delete? we shall see
    #     """
    #     days = range(1, len(stop_loss_data) + 1)
    #     plt.scatter(days, network_decision_data,
    #                 c=stop_loss_data, cmap='RdYlGn')
    #     plt.xlabel("Day")
    #     plt.ylabel("Network Decision")
    #     plt.xticks(days)
    #     plt.yticks([0, 1, 2], ["buy", "hold", "sell"])
    #     timestamp = dt.datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
    #     plt.savefig(
    #         f"Figures/{timestamp}_stop_losses_triggered_gen{gen_id}_pop_{pop_id}.png")


if __name__ == '__main__':

    # Scatter plotting testing data
    profit_data_1 = [12000, 15000, 2000, 20000, 55000]
    drawdown_data_1 = [58000, 20000, 32000, 80000, 55000]

    profit_data_2 = [1000, 2000, 5000, 8000, 10000, 15000, 18000,
                     30000, 35000, 40000, 62000, 90000, 95000, 99000, 100000]
    drawdown_data_2 = [5000, 10000, 15000, 20000, 35000, 40000,
                       50000, 62000, 65000, 70000, 75000, 80000, 85000, 92000, 100000]

    profit_data_3 = [5000, 6000, 7000, 1000, 12000]
    drawdown_data_3 = [24000, 2000, 3000, 6000, 2500]

    # Stop loss trigger plotting testing data
    stop_loss_step_data = [0, 1, 0, 1, 0]
    network_decision_data = [0, 1, 2, 1, 0]

    # Test instantiation
    # plotter = Plotter()

    # Test methods
    # plotter.update_interactive_convergence_scatter(
    #     profit_data_1, drawdown_data_1, 1)
    # plotter.update_interactive_convergence_scatter(
    #     profit_data_2, drawdown_data_2, 2)
    # plotter.update_interactive_convergence_scatter(
    #     profit_data_3, drawdown_data_3, 3)

    # plotter.create_standard_scatter(profit_data_1, drawdown_data_1)
    # plotter.create_standard_scatter(profit_data_2, drawdown_data_2)
    # plotter.create_standard_scatter(profit_data_3, drawdown_data_3)

    # plotter.stop_losses_triggered(stop_loss_step_data, network_decision_data, (1, 2))

    print("Done")
